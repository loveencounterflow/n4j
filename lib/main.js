// Generated by CoffeeScript 1.7.1
(function() {
  var ASYNC, TRM, TYPES, alert, badge, db_route, debug, echo, help, info, log, mk_request, rainbow, rpr, urge, warn, whisper;

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'n4j';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  ASYNC = require('async');

  mk_request = require('request');


  /* TAINT should use proper options */

  db_route = 'http://localhost:7474/db/data/cypher';

  this._request = function(query, handler) {
    var http_options, rq;
    http_options = {
      url: db_route,
      method: 'POST',
      json: true,
      body: query
    };
    rq = mk_request(http_options, (function(_this) {
      return function(error, response, body) {
        var columns, data, entry, entry_idx, exception, isa_node, kernel, message, row, self, _i, _j, _len, _len1;
        if (error != null) {
          return handler(error);
        }
        exception = body.exception, message = body.message;
        if (exception != null) {
          return handler(new Error(exception + ': ' + message));
        }
        data = body.data, columns = body.columns;
        if (data != null) {
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            row = data[_i];
            for (entry_idx = _j = 0, _len1 = row.length; _j < _len1; entry_idx = ++_j) {
              entry = row[entry_idx];
              if (!TYPES.isa_pod(entry)) {
                continue;
              }
              if ((self = entry.self, entry) == null) {
                continue;
              }
              kernel = entry['data'];
              if (!TYPES.isa_pod(kernel)) {
                continue;
              }
              if (isa_node = /\/node\/[0-9]+$/.test(self)) {
                kernel['~isa'] = 'node';
              } else {
                kernel['~isa'] = 'edge';
              }
              row[entry_idx] = kernel;
            }
          }
        }
        return handler(null, data, columns);
      };
    })(this));
    return null;
  };

  this.clear_db = function(handler) {
    var query;
    query = {
      query: "MATCH (n)\nOPTIONAL MATCH (n)-[r]-()\nDELETE n, r;"
    };
    this._request(query, (function(_this) {
      return function(error, data, columns) {
        if (error != null) {
          return handler(error);
        }
        return handler(null);
      };
    })(this));
    return null;
  };

  this.read_labels = function(handler) {
    var query;
    query = {
      query: "MATCH n RETURN DISTINCT LABELS( n )"
    };
    this._request(query, (function(_this) {
      return function(error, rows) {
        var Z, label, row, _i, _j, _len, _len1;
        if (error != null) {
          return handler(error);
        }
        Z = {};
        for (_i = 0, _len = rows.length; _i < _len; _i++) {
          row = rows[_i];
          for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
            label = row[_j];
            Z[label] = 1;
          }
        }
        return handler(null, (function() {
          var _results;
          _results = [];
          for (label in Z) {
            _results.push(label);
          }
          return _results;
        })());
      };
    })(this));
    return null;
  };

  this.read_names_by_label = function(handler) {

    /* Yields a POD whose keys are labels and whose values are lists of property names found for objects
    with that label. Note that results are only reliable for collections where all elements have exactly
    one label and all objects with the same label have the exact same property names defined.
     */
    this.read_labels((function(_this) {
      return function(error, labels) {
        var label, on_finish, tasks, _fn, _i, _len;
        if (error != null) {
          throw error;
        }
        info(labels);
        tasks = [];
        _fn = function(label) {
          return tasks.push(function(async_handler) {
            var query;
            query = {
              query: "MATCH (n:" + (_this._escape_name(label)) + ") RETURN n LIMIT 1"
            };
            return _this._request(query, function(error, rows) {
              return async_handler(error, rows[0][0]);
            });
          });
        };
        for (_i = 0, _len = labels.length; _i < _len; _i++) {
          label = labels[_i];
          _fn(label);
        }
        on_finish = function(error, nodes) {
          var Z, name, node, target, _j, _len1;
          if (error != null) {
            throw error;
          }
          whisper(nodes);
          Z = {};
          for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
            node = nodes[_j];
            target = Z[node['~label']] = [];
            for (name in node) {
              target.push(name);
            }
          }
          urge(Z);
          return handler(null, Z);
        };
        return ASYNC.parallelLimit(tasks, 10, on_finish);
      };
    })(this));
    return null;
  };

  this._escape = function(x) {
    var type;
    switch (type = TYPES.type_of(x)) {
      case 'pod':
        return this._escape_pod(x);
      case 'node':
        return this._escape_node(x);
      default:
        return JSON.stringify(x);
    }
  };

  this._escape_name = function(x) {
    return '`' + (x.replace(/`/g, '``')) + '`';
  };

  this._escape_pod = function(x) {
    var R, name, value;
    R = (function() {
      var _results;
      _results = [];
      for (name in x) {
        value = x[name];
        _results.push((this._escape_name(name)) + ': ' + this._escape(value));
      }
      return _results;
    }).call(this);
    return "{ " + (R.join(', ')) + " }";
  };

  this._escape_node = function(x) {
    var data, label, _ref;
    label = this._escape_name((_ref = x['~label']) != null ? _ref : 'nolabel');
    data = this._escape_pod(x);
    return "(:" + label + " " + data + ")";
  };

}).call(this);
